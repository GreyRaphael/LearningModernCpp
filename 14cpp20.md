# C++20 libraries

- [C++20 libraries](#c20-libraries)
  - [`std::format`](#stdformat)
  - [`std::ranges`](#stdranges)
    - [projection](#projection)
    - [transform](#transform)
    - [split \& join](#split--join)
    - [sort](#sort)
  - [`std::span`](#stdspan)
  - [`std:jthread`](#stdjthread)
  - [`auto`](#auto)
    - [unconstrained `auto`](#unconstrained-auto)
    - [constrained `auto` of `concept`](#constrained-auto-of-concept)
  - [`std::erase`](#stderase)
  - [`concepts`](#concepts)
    - [common used concepts](#common-used-concepts)
    - [comparing numbers](#comparing-numbers)
    - [computing the average](#computing-the-average)
    - [factory with variable arguments](#factory-with-variable-arguments)
    - [concept with std::optional](#concept-with-stdoptional)
  - [structured bindings](#structured-bindings)
  - [c++20 ezlog](#c20-ezlog)
  - [`std::chrono`](#stdchrono)
    - [`last_write_time` with timezone](#last_write_time-with-timezone)
  - [Designated Initializers](#designated-initializers)
  - [optimize heterogeneous lookup `contains`](#optimize-heterogeneous-lookup-contains)
  - [smart pointers](#smart-pointers)
  - [`std::to_chars()` and `std::from_chars()`](#stdto_chars-and-stdfrom_chars)
    - [`std::to_chars()`](#stdto_chars)
    - [`std::from_chars()`](#stdfrom_chars)
  - [parent class as argument, genenrate child class](#parent-class-as-argument-genenrate-child-class)
  - [`std::async`](#stdasync)
    - [`std::async` with lambda](#stdasync-with-lambda)
  - [`std::bit_cast` vs `reinterpret_cast`](#stdbit_cast-vs-reinterpret_cast)

## `std::format`

format with std::formt

```cpp
#include <array>
#include <cstdio>
#include <format>
#include <iostream>

int main() {
    int number = 42;
    {
        // ary char array
        char buffer[7];
        std::sprintf(buffer, "%06d", number);
        std::cout << buffer << '\n';
    }
    {
        // by std::array
        std::array<char, 7> buffer_array{};
        std::snprintf(buffer_array.data(), buffer_array.size(), "%06d", number);
        std::cout << buffer_array.data() << '\n';
    }
    {
        // by std::format
        std::cout << std::format("{:06d}", number) << '\n';
    }
}
```

## `std::ranges`

C++17 use [ranges](https://github.com/ericniebler/range-v3)
> `vcpkg install range-v3`

```cmake
find_package(range-v3 CONFIG REQUIRED)
target_link_libraries(my_project PRIVATE range-v3::meta range-v3::concepts range-v3::range-v3)
```

simple usage of `ranges`

```cpp
#include <iostream>
#include <ranges>

int main() {
    // [1, 10), std::views in <ranges>
    for (auto i : std::views::iota(1, 10)) {
        std::cout << i << ' ';
    }
}
```

ranges with pipeline `|`

```cpp
#include <cmath>
#include <iostream>
#include <ranges>

bool is_prime(int const n) {
    if (n != 2) {
        if (n < 2 || n % 2 == 0) return false;
        auto root = std::sqrt(n);
        for (int i = 3; i <= root; i += 2) {
            if (n % i == 0) return false;
        }
    }
    return true;
}

int main() {
    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    auto v = {1, 2, 3, 4, 5, 6, 7, 8, 9};  // initializer_list
    for (auto i : v | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime) | std::views::transform([](int const n) { return n + 1; })) {
        std::cout << i << ' ';
    }  // 3 4 6 8
    std::cout << '\n';

    // take(): take the first-N elements
    // drop(): drop the first-N elements
    for (auto i : std::views::iota(1, 10) | std::views::reverse | std::views::filter(is_prime) | std::views::take(3) | std::views::reverse | std::views::drop(1)) {
        std::cout << i << ' ';
    }  // 5 7
    std::cout << '\n';
}
```

ranges with algorithms

```cpp
#include <algorithm>  // max,sort,reverse,copy, count_if...in-place
#include <iostream>
#include <iterator>  // std::ostream_iterator
#include <ranges>
#include <vector>

int main() {
    // algorithms
    std::vector v{5, 2, 7, 1, 4, 2, 9, 5};
    std::cout << std::ranges::max(v) << '\n';           // 9
    std::cout << *std::ranges::max_element(v) << '\n';  // 9

    std::ranges::sort(v);
    for (auto& e : v) std::cout << e << ' ';  // 1 2 2 4 5 5 7 9
    std::cout << '\n';

    std::ranges::reverse(v);
    std::ranges::copy(v, std::ostream_iterator<int>(std::cout, ","));  // 9,7,5,5,4,2,2,1,
    std::cout << '\n';

    auto n = std::ranges::count_if(v, [](int const n) { return n % 2 == 0; });
    std::cout << n << '\n';  // 3
}
```

### projection

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <string>
#include <utility>

void printIterable(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << e << ' ';
    }
    std::cout << '\n';
}

void printPairs(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << std::format("({}, {}) ", e.first, e.second);
    }
    std::cout << '\n';
}

int main() {
    {
        int arr[] = {7, 2, 3, 5};
        // sort ascending
        std::ranges::sort(arr);  // std::ranges::less{}
        printIterable(arr);      // 2 3 5 7
    }
    {
        int arr[] = {7, 2, 3, 5};
        // sort descending
        std::ranges::sort(arr, std::ranges::greater{});
        printIterable(arr);  // 7 5 3 2
    }
    {
        std::pair<int, std::string> arr[] = {
            {7, "seven"},
            {2, "two"},
            {3, "three"},
            {5, "five"},
        };
        // sort descending by first element as projection
        std::ranges::sort(arr, std::ranges::greater{}, [](auto const& p) { return p.first; });
        printPairs(arr);  // (7, seven) (5, five) (3, three) (2, two)
    }
}
```

projection with struct

```cpp
#include <algorithm>
#include <format>
#include <iostream>
#include <ranges>
#include <vector>

struct Box {
    std::string name;
    double w = 0.0;
    double h = 0.0;
    double d = 0.0;

    constexpr double volume() const { return w * h * d; }
};

void print(std::string_view intro, const std::vector<Box>& container) {
    std::cout << intro << '\n';
    for (const auto& elem : container)
        std::cout << std::format("{}, volume {}\n", elem.name, elem.volume());
}

int main() {
    std::vector<Box> container{
        {"large cubic", 10, 10, 10},
        {"small cubic", 3, 3, 3},
        {"large long", 10, 2, 2},
        {"small", 3, 2, 2},
    };

    std::ranges::sort(container, {}, &Box::name);  // project by field
    print("===>after sorting by name", container);
    std::ranges::sort(container, {}, &Box::volume);  // projection by method
    print("===>after sorting by volume", container);
}
```

sort by secondary key

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <ranges>
#include <tuple>
#include <vector>

template <typename Proj = std::identity>
void PrintEx(const std::ranges::range auto& container, Proj proj = {}) {
    for (size_t i = 0; auto&& elem : container)
        std::cout << std::invoke(proj, elem) << (++i == container.size() ? "\n" : ", ");
};

struct Score {
    int math;
    int physics;
    std::string name;
};

int main() {
    std::vector<Score> scores = {
        {5, 6, "moris"},
        {2, 4, "tom"},
        {1, 1, "jerry"},
        {1, 0, "bob"},
        {8, 10, "grey"},
    };
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (5,6,moris), (2,4,tom), (1,1,jerry), (1,0,bob), (8,10,grey)

    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return x.math < y.math; }); // sort by single field
    std::ranges::sort(scores, {}, &Score::math);
    // (1,1,jerry), (1,0,bob), (2,4,tom), (5,6,moris), (8,10,grey)

    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // use std::make_tuple
    // math in desc order, name[0] in asc order
    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return std::make_tuple(-x.math, x.name[0]) < std::make_tuple(-y.math, y.name[0]); }); // method1
    std::ranges::sort(scores, {}, [](auto const& x) { return std::make_tuple(-x.math, x.name[0]); });  // method2
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (8,10,grey), (5,6,moris), (2,4,tom), (1,0,bob), (1,1,jerry)
};
```

### transform

```cpp
#include <algorithm>
#include <iostream>
#include <ranges>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    std::vector<Product> prods{7, {"Box ", 1.0}};

    // standard version:
    std::transform(prods.begin(), prods.end(), prods.begin(), [v = 0](const Product &p) mutable {
        return Product{p.name_ + std::to_string(v++), 1.0};
    });
    for (auto &p : prods) std::cout << p.name_ << ", ";
    std::cout << '\n';

    // ranges version:
    std::ranges::transform(prods, prods.begin(), [v = 0](const std::string &n) mutable { return Product{n + std::to_string(v++), 1.0}; }, &Product::name_);
    for (auto &p : prods) std::cout << p.name_ << ", ";
}
```


```cpp
#include <algorithm>
#include <iostream>
#include <map>
#include <ranges>

template <typename T>
size_t MaxKeyLength(const std::map<std::string, T>& m) {
    if (m.empty())
        return 0;
    auto res = std::ranges::max_element(std::views::keys(m),
                                        std::less{}, &std::string::length  // <<
    );
    return (*res).length();
}

int main() {
    const std::map<std::string, std::array<double, 5>> productToOrders{
        {"apples", {100, 200, 50.5, 30, 10}},
        {"bananas", {80, 10, 100, 120, 70}},
        {"carrots", {130, 75, 25, 64.5, 128}},
        {"tomatoes", {70, 100, 170, 80, 90}}};
    auto maxKeyLength = MaxKeyLength(productToOrders);
    std::cout << maxKeyLength << '\n';  // 8
}
```

transform with two ranges

```cpp
#include <algorithm>
#include <format>
#include <iostream>
#include <ranges>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    std::vector<Product> prods{7, {"Box", 1.0}};
    auto nums = std::views::iota(1, 3);
    // combine two ranges
    std::ranges::transform(prods, nums, prods.begin(), [](auto &p, auto n) {
        return Product{std::format("{}-{}", p.name_, n), p.value_};
    });
    for (auto &p : prods) std::cout << p.name_ << ','; // Box-1,Box-2,Box,Box,Box,Box,Box,
}
```

### split & join

split string

```cpp
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>

auto split(std::string_view s, std::string_view delim) {
    std::vector<std::string_view> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::string source{"Hello^_^C++^_^20^_^!"};
    std::string delims = "^_^";
    auto result = split(source, delims);
    for (auto &&e : result) {
        std::cout << e << std::endl;
    }
}
```

split vector of int

```cpp
#include <iostream>
#include <ranges>
#include <vector>

auto split(std::span<int> s, std::span<int> delim) {
    std::vector<std::span<int>> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::vector source = {1, 2, 3, 6, 6, 2, 3, 4, 6, 6, 8};
    std::vector delims = {6, 6};
    auto result = split(source, delims);
    for (auto &&v : result) {
        for (auto &&e : v) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
}
// 1 2 3 
// 2 3 4 
// 8 
```

join strings and vectors

```cpp
#include <ranges>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto result = v | std::views::join;
        std::string output{result.begin(), result.end()};  // helloworldgrey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        auto result = v | std::views::join;
        std::vector<int> output{};
        output.insert(output.begin(), result.begin(), result.end());  // 1 1 2 2 3 3
    }
}
```

`join` by range-v3, recommended
> but `split` by range-v3 is not recommended

```cpp
#include <range/v3/all.hpp>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto output = v | ranges::views::join("||") | ranges::to<std::string>();  // hello||world||grey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        std::vector delims{6, 6};
        auto output = v | ranges::views::join(delims) | ranges::to<std::vector>();  // 1 1 6 6 2 2 6 6 3 3
    }
}
```

### sort

range sort with secondary key by `std::tie`

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

struct MyStruct {
    int field1;
    std::string field2;
};

int main() {
    std::vector<MyStruct> vec = {{2, "banana"}, {1, "apple"}, {2, "apple"}, {1, "banana"}};

    std::ranges::sort(vec, [](const MyStruct& a, const MyStruct& b) {
        return std::tie(a.field1, a.field2) < std::tie(b.field1, b.field2);
    });

    for (const auto& elem : vec) {
        std::cout << elem.field1 << " " << elem.field2 << "\n";
    }
}
```

## `std::span`

`std::span` is a lightweight, non-owning **view** over a **contiguous sequence** of objects, which can be used with **C-style arrays**, `std::array`, `std::vector`, and similar container types.
> `std::span` in [details](https://www.cppstories.com/2023/span-cpp20/)

```cpp
#include <iostream>
#include <span>
#include <vector>

void printSpan(std::span<const int> s) {
    for (auto elem : s) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}

int main() {
    // Creating a span from a std::vector
    std::vector<int> vec = {1, 2, 3, 4};
    std::span<int> spanVec(vec);
    printSpan(spanVec);  // 1 2 3 4

    // Creating a span from a C-style array
    int arr[] = {5, 6, 7, 8};
    std::span<int> spanArr(arr);
    printSpan(spanArr);  // 5 6 7 8

    // Creating a span from a std::array
    std::array<int, 5> arr2 = {11, 22, 33, 44, 55};
    std::span<int> spanArr2(arr2);
    printSpan(spanArr2);  // 11 22 33 44 55

    // subspan
    auto first3sp = spanArr2.first(3);
    printSpan(first3sp);  // 11 22 33

    auto last3sp = spanArr2.last(3);
    printSpan(last3sp);  // 33 44 55

    auto middle3sp = spanArr2.subspan(1, 3);
    printSpan(middle3sp);  // 22 33 44
}
```

`std::span<T>` & `std::span<const T>`

```cpp
#include <iostream>
#include <span>
#include <string>

void transform(std::span<char> outbuf) {
    for (auto& elem : outbuf) {
        elem += 1;
    }
}

void output(std::span<const char> outbuf) {
    std::cout << "contents: ";
    for (auto& elem : outbuf) {
        std::cout << elem << ", ";
        // elem = 0;  // error!
    }
    std::cout << '\n';
}

int main() {
    std::string str = "Hello World";
    std::span<char> buf_span(str);

    output(str);

    transform(buf_span);

    output(buf_span);  // contents: I, f, m, m, p, !, X, p, s, m, e,
    output(str);       // contents: I, f, m, m, p, !, X, p, s, m, e,
}
```

## `std:jthread`

jthread with bracket

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// ====================
// worker-2 start
// worker-3 start
// worker-4 start
// worker-1 start
// worker-1 finish
// worker-4 finish
// worker-3 finish
// worker-2 finish
```

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
    }
    // wait t1, t2 finished
    {
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// worker-1 start
// worker-2 start
// worker-2 finish
// worker-1 finish
// ====================
// worker-3 start
// worker-4 start
// worker-4 finish
// worker-3 finish
```

## `auto`

### unconstrained `auto`

```cpp
// before C++20
template <typename T>
void myTemplateFunc(T param) {}

// equivalent, since C++20
void myTemplateFunc(auto param) {}
```

```cpp
#include <iostream>

// before C++20
template <typename T>
void printValOld(T v) {
    std::cout << v << '\n';
}

// since C++20
void printValNew(auto v) {
    std::cout << v << '\n';
}

int main() {
    // before
    printValOld(10);
    printValOld(1.2);
    printValOld<long>(100);

    // since C++20
    printValNew(20);
    printValNew(2.3);
    printValNew<long>(200);
}
```

### constrained `auto` of `concept`

```cpp
#include <concepts>

class A {};

class B : public A {};

class C {};

// custom concept
template <class T>
concept SignedIntegral = std::is_signed_v<T> && std::is_integral_v<T>;

void myfunc1(SignedIntegral auto val) {}

// standard concepts
void myfunc2(std::floating_point auto fp) {}
void myfunc3(std::signed_integral auto param) {}
void myfunc4(std::unsigned_integral auto param) {}
void myfunc5(std::derived_from<A> auto param) {}

int main() {
    A a{};
    B b{};
    C c{};
    myfunc5(a);  // ok
    myfunc5(b);  // ok
    // myfunc5(c);  // error
}
```

## `std::erase`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    // erase a single value
    std::erase(vec, 5);
    // erase by predicate
    std::erase_if(vec, [](auto& v) { return v % 2 == 0; });
    for (int i = 0; auto& v : vec)
        std::cout << i++ << ": " << v << '\n';  // 1 3 7 9
}
```

```cpp
#include <iostream>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    const std::vector<Product> prods{
        {"box", 10.0},
        {"tv", 100.0},
        {"rocket", 10000.0},
        {"no prod", 0.0},
        {"car", 1000.0},
        {"toy", 40.0},
        {"none", 0.0}};

    auto printCont = [](const std::vector<Product>& cont) {
        for (auto& p : cont) std::cout << p.name_ << ", ";
        std::cout << '\n';
    };
    printCont(prods);

    auto checkNoPrefix = [&](const Product& p) { return p.name_.starts_with("no"); };

    auto tempProds = prods; // const to mutable
    // C++20 version:
    std::erase_if(tempProds, checkNoPrefix);
    printCont(tempProds);
}
```

## `concepts`

### common used concepts

where to place `concept`

```cpp
// concept before auto in return & parameter
std::integral auto mod(std::integral auto v, std::integral auto n) {
    return v % n;
}

template <std::integral T>
auto mod(T v, T n) {
    return v % n;
}

template <std::integral T>
struct Foo {
    T value;
};
```

`std::ranges::range` concept

```cpp
#include <algorithm>  // For std::ranges::for_each
#include <iostream>
#include <ranges>
#include <vector>

// Function using a range-based for loop
void func_range_based_for(std::ranges::range auto const& r) {
    std::cout << "Elements (using range-based for loop): ";
    for (const auto& elem : r) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}

// Function using std::ranges::for_each
void func_ranges_for_each(std::ranges::range auto const& r) {
    std::cout << "Elements (using std::ranges::for_each): ";
    std::ranges::for_each(r, [](const auto& elem) {
        std::cout << elem << ' ';
    });
    std::cout << '\n';
}

int main() {
    std::vector v{1, 2, 3, 4, 5};
    // if implemented `begin()` and `end()`, it meet std::ranges::range concept

    func_range_based_for(v);
    func_ranges_for_each(v);
}
```

### comparing numbers

```cpp
#include <concepts>
#include <cstdlib>
#include <type_traits>

template <typename T>
constexpr auto precision_threshold = T(1e-6);

// in c++17, if constexpr
template <typename T>
constexpr bool close_enough(T a, T b) {
    if constexpr (std::is_floating_point_v<T>)
        return std::abs(a - b) < precision_threshold<T>;
    else
        return a == b;
}

// in c++20, by concepts
template <typename T>
    requires std::is_floating_point_v<T>
constexpr bool close_enough20(T a, T b) {
    return std::abs(a - b) < precision_threshold<T>;
}
constexpr bool close_enough20(auto a, auto b) {
    return a == b;
}

// c++20, simplified 01, recommended
constexpr bool close_enough201(std::floating_point auto a, std::floating_point auto b) {
    return std::abs(a - b) < precision_threshold<std::common_type_t<decltype(a), decltype(b)>>;
}
constexpr bool close_enough201(std::integral auto a, std::integral auto b) {
    return a == b;
}

// c++20, simplified 02
template <std::floating_point T>
constexpr bool close_enough202(T a, T b) {
    return absolute(a - b) < precision_threshold<T>;
}

constexpr bool close_enough202(std::integral auto a, std::integral auto b) {
    return a == b;
}

int main() {
    // c++17
    static_assert(close_enough(10, 20) == false);
    static_assert(close_enough(10, 10) == true);
    static_assert(close_enough(10.1, 10.1) == true);
    static_assert(close_enough(10.0000001, 10.0000005) == true);
    // c++20
    static_assert(close_enough20(10, 20) == false);
    static_assert(close_enough20(10, 10) == true);
    static_assert(close_enough20(10.1, 10.1) == true);
    static_assert(close_enough20(10.0000001, 10.0000005) == true);
}
```

### computing the average

```cpp
#include <iostream>
#include <numeric>
#include <type_traits>
#include <vector>

template <typename T>
    requires std::is_integral_v<T> || std::is_floating_point_v<T>
constexpr double Average(std::vector<T> const &vec) {
    const double sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / static_cast<double>(vec.size());
}

template <typename T>
concept numeric = std::is_integral_v<T> || std::is_floating_point_v<T>;

template <typename T>
    requires numeric<T>
constexpr double Average2(std::vector<T> const &vec) {
    const double sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / static_cast<double>(vec.size());
}

// simplest, <numeric auto> not support in clang18
constexpr auto Average3(std::vector<numeric auto> const &vec) {
    const auto sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / vec.size();
}

int main() {
    std::vector ints{1, 2, 3, 4, 5};
    std::cout << Average3(ints) << '\n';

    std::vector floats{1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
    std::cout << Average3(floats) << '\n';
}
```

### factory with variable arguments

```cpp
#include <iostream>
#include <memory>

class Investment {
   public:
    virtual ~Investment() {}

    virtual void calcRisk() = 0;
};

class Stock : public Investment {
   public:
    explicit Stock(const std::string &) {}

    void calcRisk() override {
        std::cout << "===>stock risk" << '\n';
    }
};

class Bond : public Investment {
   public:
    explicit Bond(const std::string &, const std::string &, int) {}

    void calcRisk() override {
        std::cout << "===>bond risk" << '\n';
    }
};

class RealEstate : public Investment {
   public:
    explicit RealEstate(const std::string &, double, int) {}

    void calcRisk() override {
        std::cout << "===>realestate risk" << '\n';
    }
};

// C++17
template <typename Concrete, typename... Ts>
std::unique_ptr<Concrete> constructArgs17(Ts &&...params) {
    if constexpr (std::is_constructible_v<Concrete, Ts...>)
        return std::make_unique<Concrete>(std::forward<Ts>(params)...);
    else
        return nullptr;
}

// C++17
template <typename... Ts>
std::unique_ptr<Investment> makeInvestment17(const std::string &name, Ts &&...params) {
    std::cout << __func__ << ", " << name << std::endl;

    std::unique_ptr<Investment> pInv;

    if (name == "Stock")
        pInv = constructArgs17<Stock, Ts...>(std::forward<Ts>(params)...);
    else if (name == "Bond")
        pInv = constructArgs17<Bond, Ts...>(std::forward<Ts>(params)...);
    else if (name == "RealEstate")
        pInv = constructArgs17<RealEstate, Ts...>(std::forward<Ts>(params)...);

    if (pInv) {
        pInv->calcRisk();  // calc initial risk and cache result...
    } else
        std::cout << "nullptr from \'makeInvestment17\'" << std::endl;

    return pInv;
}

// C++20:
template <typename Concrete, typename... Ts>
    requires std::is_constructible_v<Concrete, Ts...>
std::unique_ptr<Concrete> constructArgs20(Ts &&...params) {
    return std::make_unique<Concrete>(std::forward<Ts>(params)...);
}

template <typename Concrete, typename... Ts>
std::unique_ptr<Concrete> constructArgs20(...) {
    return nullptr;
}

// C++20
template <typename... Ts>
std::unique_ptr<Investment> makeInvestment20(const std::string &name, Ts &&...params) {
    std::cout << __func__ << ", " << name << std::endl;

    std::unique_ptr<Investment> pInv;

    if (name == "Stock")
        pInv = constructArgs20<Stock, Ts...>(std::forward<Ts>(params)...);
    else if (name == "Bond")
        pInv = constructArgs20<Bond, Ts...>(std::forward<Ts>(params)...);
    else if (name == "RealEstate")
        pInv = constructArgs20<RealEstate, Ts...>(std::forward<Ts>(params)...);

    if (pInv) {
        pInv->calcRisk();  // calc initial risk and cache result...
    } else
        std::cout << "nullptr from \'makeInvestment20\'" << std::endl;

    return pInv;
}

int main() {
    // C++17
    {
        auto noArgs = makeInvestment17("Stock");
        auto pStock = makeInvestment17("Stock", "abc");
        auto pBond = makeInvestment17("Bond", "xyz", "2210", 5);
        auto pRealEstate = makeInvestment17("RealEstate", "CA", 0.75, 10);
        auto nothing = makeInvestment17("SomethingElse", '?');
    }
    // C++20
    {
        auto noArgs = makeInvestment20("Stock");
        auto pStock = makeInvestment20("Stock", "abc");
        auto pBond = makeInvestment20("Bond", "xyz", "2210", 5);
        auto pRealEstate = makeInvestment20("RealEstate", "CA", 0.75, 10);
        auto nothing = makeInvestment20("SomethingElse", '?');
    }
}
```

### concept with std::optional

```cpp
#include <optional>

template <typename T>
concept IsOptional = std::is_same_v<T, std::optional<typename T::value_type>>;

void exampleFunction(IsOptional auto opt) {
    // Your code here
}

int main() {
    std::optional<int> optInt;
    exampleFunction(optInt);  // This will work

    int notOptional;
    exampleFunction(notOptional);  // This will cause a compile-time error
}
```

## structured bindings

since c++17

```cpp
#include <array>
#include <iostream>
#include <map>
#include <string>
#include <tuple>
#include <utility>

struct Student {
    int id;
    std::string name;
    double gpa;
};

int main(int argc, char const* argv[]) {
    {
        // pair, 2 elements
        auto p = std::make_pair(10, 1.2);
        auto [first, second] = p;
        auto const& [first2, second2] = p;
    }
    {
        // tuple
        auto t = std::make_tuple(1, 2.2, 'c', "string");
        auto [a, b, c, d] = t;
        std::cout << d << '\n';
    }
    {
        // c-array
        double arr1[3] = {1.1, 2.2, 3.3};
        auto [a, b, c] = arr1;
        // std::array
        std::array arr2 = {1, 2, 3};
        auto [x, y, z] = arr2;
    }
    {
        // struct with non-static data members
        Student s = {1, "name", 3.3};
        auto [id, name, gpa] = s;
    }
    {
        // map
        std::map<std::string, int> m = {{"one", 1111}, {"two", 2222}, {"three", 3333}};
        for (auto const& [k, v] : m) {
            std::cout << k << ": " << v << '\n';
        }
        // iter with counter
        for (auto i = 1; auto const& [k, v] : m) {
            std::cout << i++ << ':' << k << ": " << v << '\n';
        }
    }
}
```

## c++20 ezlog

method1: `ezlog` by `std::source_location` and [user-defined-deduction-guides]((https://en.cppreference.com/w/cpp/language/class_template_argument_deduction#User-defined_deduction_guides))
> not friendly for clangd auto insert

```cpp
// ezlog.hpp
#pragma once

#include <chrono>
#include <filesystem>
#include <format>
#include <iostream>
#include <source_location>
#include <string_view>

namespace ezlog {

enum class log_level : unsigned char {
    Debug = 34,    // BLUE
    Info = 32,     // GREEN
    Warning = 33,  // YELLOW
    Error = 31,    // RED
};

constexpr std::string_view level2txt(log_level const level) {
    switch (level) {
        case log_level::Debug:
            return "debug";
        case log_level::Info:
            return "info";
        case log_level::Warning:
            return "warn";
        case log_level::Error:
            return "error";
        default:
            return "unknown";
    }
}

inline void log(log_level const level, std::string_view message, std::source_location const source = std::source_location::current()) {
    auto now = std::chrono::floor<std::chrono::milliseconds>(std::chrono::system_clock::now());
    auto zoned_time_str = std::format("{:%F %H:%M:%S}", std::chrono::zoned_time{std::chrono::current_zone(), now});
    auto loc_str = std::format("{}:{}", std::filesystem::path(source.file_name()).filename().string(), source.line());
    auto color_flag = std::format("\033[{}m{}\033[0m", static_cast<unsigned char>(level), level2txt(level));
    std::cout << std::format("[{}] [{}] [{}] {}\n", color_flag, zoned_time_str, loc_str, message);
}

template <typename Fmt, typename... Args>
struct debug {
    debug(Fmt fmt, Args&&... args, const std::source_location& loc = std::source_location::current()) {
        auto msg = std::vformat(fmt, std::make_format_args(args...));
        log(log_level::Debug, msg, loc);
    }
};

template <typename Fmt, typename... Args>
struct info {
    info(Fmt fmt, Args&&... args, const std::source_location& loc = std::source_location::current()) {
        auto msg = std::vformat(fmt, std::make_format_args(args...));
        log(log_level::Info, msg, loc);
    }
};

template <typename Fmt, typename... Args>
struct warn {
    warn(Fmt fmt, Args&&... args, const std::source_location& loc = std::source_location::current()) {
        auto msg = std::vformat(fmt, std::make_format_args(args...));
        log(log_level::Warning, msg, loc);
    }
};

template <typename Fmt, typename... Args>
struct error {
    error(Fmt fmt, Args&&... args, const std::source_location& loc = std::source_location::current()) {
        auto msg = std::vformat(fmt, std::make_format_args(args...));
        log(log_level::Error, msg, loc);
    }
};

template <typename... Args>
debug(std::string_view fmt, Args&&...) -> debug<std::string_view, Args...>;

template <typename... Args>
info(std::string_view fmt, Args&&...) -> info<std::string_view, Args...>;

template <typename... Args>
warn(std::string_view fmt, Args&&...) -> warn<std::string_view, Args...>;

template <typename... Args>
error(std::string_view fmt, Args&&...) -> error<std::string_view, Args...>;

}  // namespace ezlog
```

method2: `ezlog` by struct, [idea](https://stackoverflow.com/questions/57547273/how-to-use-source-location-in-a-variadic-template-function)
> friendly for clangd auto insert

```cpp
// ezlog.hpp
#pragma once

#include <chrono>
#include <filesystem>
#include <format>
#include <iostream>
#include <source_location>
#include <string_view>

namespace ezlog {

enum class log_level : unsigned char {
    Debug = 34,    // BLUE
    Info = 32,     // GREEN
    Warning = 33,  // YELLOW
    Error = 31,    // RED
};

constexpr std::string_view level2txt(log_level const level) {
    switch (level) {
        case log_level::Debug:
            return "debug";
        case log_level::Info:
            return "info";
        case log_level::Warning:
            return "warn";
        case log_level::Error:
            return "error";
        default:
            return "unknown";
    }
}

inline void log(log_level const level, std::string_view message, std::source_location const source = std::source_location::current()) {
    auto now = std::chrono::floor<std::chrono::milliseconds>(std::chrono::system_clock::now());
    auto zoned_time_str = std::format("{:%F %H:%M:%S}", std::chrono::zoned_time{std::chrono::current_zone(), now});
    auto loc_str = std::format("{}:{}", std::filesystem::path(source.file_name()).filename().string(), source.line());
    auto color_flag = std::format("\033[{}m{}\033[0m", static_cast<unsigned char>(level), level2txt(level));
    std::cout << std::format("[{}] [{}] [{}] {}\n", color_flag, zoned_time_str, loc_str, message);
}

struct Formatter {
    const char* value;
    std::source_location loc;
    Formatter(const char* fmt_str, std::source_location const& l = std::source_location::current()) : value(fmt_str), loc(l) {}
    Formatter(const Formatter&) = delete;
};

template <typename... Args>
void debug(Formatter fmt, Args&&... args) {
    auto msg = std::vformat(fmt.value, std::make_format_args(args...));
    log(log_level::Debug, msg, fmt.loc);
}

template <typename... Args>
void info(Formatter fmt, Args&&... args) {
    auto msg = std::vformat(fmt.value, std::make_format_args(args...));
    log(log_level::Info, msg, fmt.loc);
}

template <typename... Args>
void warn(Formatter fmt, Args&&... args) {
    auto msg = std::vformat(fmt.value, std::make_format_args(args...));
    log(log_level::Warning, msg, fmt.loc);
}

template <typename... Args>
void error(Formatter fmt, Args&&... args) {
    auto msg = std::vformat(fmt.value, std::make_format_args(args...));
    log(log_level::Error, msg, fmt.loc);
}
}  // namespace ezlog
```

```cpp
// usage
#include "ezlog.hpp"

int main() {
    ezlog::debug("hello");
    ezlog::debug("hello-{}", 10);
    ezlog::info("hello-{}-{}", 10, 3.14);
    ezlog::warn("hello-{}-{}-{}", 10, 3.14, 'c');
    ezlog::error("hello-{}-{}-{}-{}", 1, 2, 3, 4);
}
```

## `std::chrono`

### `last_write_time` with timezone

```cpp
#include <chrono>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>

int main() {
    {
        // temp file
        auto temp = std::filesystem::temp_directory_path() / "example01.txt";
        std::ofstream{temp} << "hello";

        auto ftime = std::filesystem::last_write_time(temp);
        std::cout << std::format("File write time is {0:%X} on {0:%F} of {0:%z}\n", ftime);

        auto sysTime = std::chrono::file_clock::to_sys(ftime);
        std::chrono::zoned_time new_zone{"Asia/Shanghai", sysTime};

        // format
        std::cout << std::format("File write time is {0:%X} on {0:%F} of {0:%z}\n", new_zone);
        // or <<
        std::cout << new_zone << std::endl;

        std::filesystem::remove(temp);
    }
    {
        // permenant file
        auto permanent_path = std::filesystem::path("./") / "example02.txt";
        std::ofstream{permanent_path} << "hello";

        auto ftime = std::filesystem::last_write_time(permanent_path);

        auto result = std::chrono::file_clock::to_sys(ftime);
        std::chrono::zoned_time new_zone{"Asia/Shanghai", result};

        // format
        std::cout << std::format("File write time is {0:%X} on {0:%F} of {0:%z}\n", new_zone);
        // or <<
        std::cout << new_zone << std::endl;
    }  // close the example02.txt file when go out of scope
}
```

sorting files by time

```cpp
#include <algorithm>
#include <chrono>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <ranges>
#include <thread>
#include <vector>

namespace fs = std::filesystem;

int main() {
    std::vector<fs::path> toDelete;

    // create some files...
    for (int i = 0; i < 5; ++i) {
        toDelete.emplace_back(std::format("example{}.txt", i));
        std::ofstream(toDelete.back()) << "Hello, World!";
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    auto it = fs::directory_iterator(".");
    std::vector<fs::directory_entry> v{it, fs::directory_iterator{}};

    // std::ranges::sort(v, {}, [](auto const& p) { return p.last_write_time(); }); // default, ascending
    std::ranges::sort(v, std::ranges::greater{}, [](auto const& p) { return p.last_write_time(); });
    for (auto&& d : v) {
        std::cout << std::format("{}, {}\n", d.last_write_time(), d.path().native());
    }

    for (auto& f : toDelete)
        fs::remove(f);
}
```

## Designated Initializers

> Designated Initialization is a form of Aggregate Initialization.

As of C++20, an Aggregate type::
- is an array type or,
- is a class type that:
  - has no private or protected direct non-static data members
  - has no user-declared or inherited constructors
  - has no virtual, private, or protected base classes
  - has no virtual member functions

```cpp
#include <iostream>

class Point {
   public:
    int x;
    int y;
};

struct Time {
    int hour;
    int minute;
    double second;
};
struct Date {
    Time t;
    int year;
    int month;
    int day;
};

int main(int argc, char const *argv[]) {
    {
        // Designated Initializers for array, c99 standard
        int arr[5] = {[0] = 1, [2] = 3, [4] = 5};
    }
    {
        // Designated Initializers for struct
        struct {
            int a;
            int b;
        } s = {.a = 1, .b = 2};

        std::cout << s.b << '\n';

        Time stu = {.hour = 20, .minute = 10, .second = 10.123};
    }
    {
        // Designated Initializers for nested struct
        Date d1{
            .t{.hour = 10, .minute = 35},
            .year = 2050,
            .month = 5,
            .day = 10};
        Date d2{.t.hour = 10, .t.minute = 23, .year = 2050, .month = 5, .day = 10};  // c99 standard
    }
    {
        // Designated Initializers for class
        Point p = {.x = 1, .y = 2};
    }
}
```

## optimize heterogeneous lookup `contains`

[tutorial](https://www.cppstories.com/2021/heterogeneous-access-cpp20/)

works for
- `std::map`
- `std::set`
- `std::multimap`
- `std::multiset`
- `std::unordered_map`
- `std::unoredered_set`
- `std::unordered_multimap`
- `std::unordered_multiset`

lookup by `contains` for ordered heterogeneous data types

```cpp
#include <functional>
#include <iostream>
#include <map>
#include <string>
#include <string_view>

// simple new/delete overloads, so we can check if some memory was allocated...
void* operator new(std::size_t sz) {
    std::cout << "Allocating: " << sz << '\n';
    return std::malloc(sz);
}

void operator delete(void* ptr) noexcept {
    std::cout << "Releasing memory" << '\n';
    std::free(ptr);
}

int main() {
    std::map<std::string, int> intMap{{"Hello Super Long String", 1}, {"Another Longish String", 2}, {"This cannot fall into SSO buffer", 3}};
    // optimized version with std::less
    std::map<std::string, int, std::less<>> trIntMap{{"Hello Super Long String", 1}, {"Another Longish String", 2}, {"This cannot fall into SSO buffer", 3}};

    std::cout << "Lookup in intMap with by const char*:\n";
    std::cout << intMap.contains("Hello Super Long String") << '\n';

    std::cout << "Lookup in trIntMap by const char*: \n";
    std::cout << trIntMap.contains("Hello Super Long String") << '\n';

    std::cout << "Lookup in trIntMap by string_view: \n";
    std::string_view sv2("Another Longish String");
    std::cout << trIntMap.contains(sv2) << '\n';
}
```


lookup by `contains` for unordered heterogeneous data types

```cpp
#include <functional>
#include <iostream>
#include <string>
#include <string_view>
#include <unordered_map>

// simple new/delete overloads, so we can check if some memory was allocated...
void* operator new(std::size_t sz) {
    std::cout << "Allocating: " << sz << '\n';
    return std::malloc(sz);
}

void operator delete(void* ptr) noexcept {
    std::cout << "Releasing memory" << '\n';
    std::free(ptr);
}

struct string_hash {
    using is_transparent = void;
    [[nodiscard]] size_t operator()(const char* txt) const {
        return std::hash<std::string_view>{}(txt);
    }
    [[nodiscard]] size_t operator()(std::string_view txt) const {
        return std::hash<std::string_view>{}(txt);
    }
    [[nodiscard]] size_t operator()(const std::string& txt) const {
        return std::hash<std::string>{}(txt);
    }
};

int main() {
    std::unordered_map<std::string, int, string_hash, std::equal_to<>>
        intMapTransparent{
            {"Hello Super Long String", 1},
            {"Another Longish String", 2},
            {"This cannot fall into SSO buffer", 3}};

    bool found = intMapTransparent.contains("Hello Super Long String");
    std::cout << "Found: " << std::boolalpha << found << '\n';
}
```

## smart pointers

```cpp
#include <memory>

struct MyObject {
    int param_{0};
    void SetParam(int p) { param_ = p; }
};

// factory to produce object
std::unique_ptr<MyObject> BuildObject(int param) {
    auto p = std::make_unique<MyObject>();
    p->SetParam(param);
    // initialize...
    return p;
}

int main() {
    // init a unique_ptr
    auto ptr = BuildObject(10);
    // init a shared_ptr by unique_ptr
    std::shared_ptr<MyObject> shared = BuildObject(100);
}
```

`std::make_shared` support array

```cpp
#include <fmt/core.h>

#include <memory>

struct Student {
    int age;
    double score;
};

int main(int, char**) {
    {
        // for simple type
        auto uptr = std::make_unique<int>(100);
        auto sptr = std::make_shared<int>(200);
        fmt::println("uptr={}, sptr={}", *uptr, *sptr);
    }
    {
        // for Instance
        auto uptr = std::make_unique<Student>(10, 68.0);
        uptr->age = 23;                                            // set value
        fmt::println("age={},scores={}", uptr->age, uptr->score);  // get value

        auto sptr = std::make_shared<Student>(13, 98.0);
        sptr->age = 25;
        fmt::println("age={},scores={}", sptr->age, sptr->score);
    }
    {
        // for simple type array
        constexpr int N = 10;
        // auto ptr = std::make_unique<int[]>(N);  // size if 10
        auto ptr = std::make_shared<int[]>(N);  // size if 10
        for (size_t i = 0; i < N; ++i) {
            ptr[i] = i * 10;
        }
        for (size_t i = 0; i < N; ++i) {
            fmt::print("{}\t", ptr[i]);
        }
        fmt::print("\n");
    }
    {
        // for instance array
        constexpr int N = 10;
        auto ptr = std::make_shared<Student[]>(N);
        // auto ptr=std::make_unique<Student[]>(N);
        for (size_t i = 0; i < N; ++i) {
            ptr[i].age = i * 10;
            ptr[i].score = i * 10.1;
        }
        for (size_t i = 0; i < N; ++i) {
            fmt::println("age={}, score={:.2f}", ptr[i].age, ptr[i].score);
        }
    }
}
```

## `std::to_chars()` and `std::from_chars()`

low-level function `std::to_chars` and `std::from_chars` are used to convert a number to a string and vice versa, since c++17
> now, `std::format` or `fmt::format` is more convenient

### `std::to_chars()`

```cpp
#include <fmt/core.h>
#include <charconv>
#include <string>

int main(int argc, char const *argv[]) {
    {
        {
            // low-level int2string
            std::string str{"xxxxxxxx"};
            const int value1 = 1986;
            std::to_chars(str.data(), str.data() + str.size(), value1, 16);
            fmt::println("{}", str);  // 7c2xxxxx
        }
        {
            // int2string
            std::string str{"xxxxxxxx"};
            const int value1 = 1986;
            std::to_chars(str.data(), str.data() + str.size(), value1);
            fmt::println("{}", str);  // 1986xxxx
        }
        {
            // double2string
            std::string str{"xxxxxxxxxxxxxxxx"};
            const double value2 = 3.1415926;
            std::to_chars(str.data(), str.data() + str.size(), value2);
            fmt::println("{}", str);  // 3.1415926xxxxxxx
        }
        {
            // double2string
            std::string str{"xxxxxxxxxxxxxxxx"};
            const double value2 = 3.1415926;
            std::to_chars(str.data(), str.data() + str.size(), value2, std::chars_format::scientific, 3);
            fmt::println("{}", str);  // 3.142e+00xxxxxxx
        }
    }
}
```

```cpp
#include <fmt/core.h>
#include <charconv>
#include <string>
#include <vector>

std::string to_string(auto value) {
    std::vector<char> buffer(8);  // Start with an initial size
    auto result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), value);
    while (result.ec == std::errc::value_too_large) {
        buffer.resize(buffer.size() * 2);  // Double the buffer size
        result = std::to_chars(buffer.data(), buffer.data() + buffer.size(), value);
    }
    if (result.ec == std::errc()) {
        std::string str(buffer.data(), result.ptr);
        return str;
    } else {
        return "";
    }
}

int main(int argc, char const *argv[]) {
    // double to string
    auto str1 = to_string(1234567890.1234567890);
    fmt::println("data={},len={}", str1, str1.size());
    // int to string
    auto str2 = to_string(1234567890);
    fmt::println("data={},len={}", str2, str2.size());
}
```

### `std::from_chars()`

```cpp
#include <fmt/core.h>
#include <charconv>
#include <string>

void parse(std::string in_str, auto& out) {
    auto [ptr, ec] = std::from_chars(in_str.data(), in_str.data() + in_str.size(), out);
    if (ec == std::errc()) {
        fmt::println("success, result={}", out);
    } else {
        fmt::println("failed, result={}", out);
    }
}

int main(int argc, char const* argv[]) {
    // string to int
    int a;
    parse("1234567890", a);
    parse("3.1415926", a);  // 3
    double d;
    parse("1234567890", d);
    parse("3.1415926", d);

    int c;
    parse("a3.1415926", c);  // failed, reuslt=0
}
```

## parent class as argument, genenrate child class

```cpp
#include <fmt/core.h>

#include <memory>
#include <vector>

struct Base {
    virtual ~Base() = default;

    virtual double work(double x) = 0;
    // interface for generate sibliing child class
    virtual std::shared_ptr<Base> new_sibling() = 0;

    double do_something(double x) {
        int sum = 0;
        for (int i = 0; i < 4; ++i) {
            sum += work(i);
        }
        return sum + x;
    }
};

struct Derived01 : Base {
    double work(double x) override {
        return x * x;
    }
    // override the class
    std::shared_ptr<Base> new_sibling() override {
        return std::move(std::make_shared<Derived01>());
    }
};

// if use class to inherit struct, must use public
class Derived02 : public Base {
    double work(double x) override {
        return x * x * x;
    }
    // override the class
    std::shared_ptr<Base> new_sibling() override {
        return std::move(std::make_shared<Derived02>());
    }
};

void func(std::shared_ptr<Base> samplePtr) {
    std::vector<std::shared_ptr<Base>> ptrs;
    ptrs.reserve(3);
    for (size_t i = 0; i < 3; ++i) {
        ptrs.emplace_back(samplePtr->new_sibling());
    }

    for (int i = 0; auto &&ptr : ptrs) {
        fmt::println("{}", ptr->do_something(i));
        ++i;
    }
}

int main(int argc, char const *argv[]) {
    auto dptr01 = std::make_shared<Derived01>();
    auto dptr02 = std::make_shared<Derived02>();
    func(dptr01);
    func(dptr02);
}
```

## `std::async`

```cpp
#include <fmt/core.h>
#include <fmt/std.h>  // formatter of std::this_thread::get_id()

#include <chrono>
#include <future>
#include <thread>
#include <vector>

int do_work01(int x) {
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    fmt::println("thread-{} pick {}", std::this_thread::get_id(), x);
    return x * x;
}

void do_work02(int x) {
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    fmt::println("thread-{} pick {}", std::this_thread::get_id(), x);
}

int main(int argc, char const *argv[]) {
    {
        // with return
        std::vector<std::future<int>> futures;
        for (size_t i = 0; i < 6; ++i) {
            futures.emplace_back(std::async(std::launch::async, do_work01, i));
        }
        fmt::println("all tasks submited");
        for (auto &&future : futures) {
            fmt::println("Result={}", future.get());
        }
    }
    {
        // without return
        std::vector<std::future<void>> futures;
        for (size_t i = 0; i < 6; ++i) {
            futures.emplace_back(std::async(std::launch::async, do_work02, i));
        }
        fmt::println("all tasks submited");
        for (auto &&future : futures) {
            future.wait();
        }
    }
    {
        // lazy evaluation with std::launch::deferred
        std::vector<std::future<void>> futures;
        for (size_t i = 0; i < 6; ++i) {
            futures.emplace_back(std::async(std::launch::deferred, do_work02, i));
        }
        fmt::println("all tasks submited");
        for (auto &&future : futures) {
            // the tasks not paralleled, all executed in the main thread
            future.wait();
        }
    }
}
```

```bash
# output
all tasks submited
thread-140437784102464 pick 0
thread-140437767194176 pick 2
thread-140437775648320 pick 1
thread-140437750285888 pick 4
thread-140437758740032 pick 3
thread-140437741831744 pick 5
Result=0
Result=1
Result=4
Result=9
Result=16
Result=25
all tasks submited
thread-140437741831744 pick 0
thread-140437758740032 pick 2
thread-140437750285888 pick 1
thread-140437767194176 pick 3
thread-140437784102464 pick 4
thread-140437775648320 pick 5
all tasks submited
thread-140437784236416 pick 0
thread-140437784236416 pick 1
thread-140437784236416 pick 2
thread-140437784236416 pick 3
thread-140437784236416 pick 4
thread-140437784236416 pick 5
```

### `std::async` with lambda

```cpp
#include <fmt/core.h>  // Make sure you have fmt library installed
#include <fmt/std.h>

#include <future>
#include <vector>

int do_work01(int x) {
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    fmt::println("thread-{} pick {}", std::this_thread::get_id(), x);
    return x * x;
}

int main(int argc, char const *argv[]) {
    std::vector<std::future<int>> futures;
    std::vector<int> numbers{10, 20, 30, 40, 50, 66};

    for (size_t i = 0; i < numbers.size(); ++i) {
        futures.emplace_back(std::async(std::launch::async, [i, &numbers]() {
            return do_work01(numbers[i]);
        }));
    }

    fmt::print("all tasks submitted\n");
    for (auto &&future : futures) {
        fmt::print("Result={}\n", future.get());
    }
}
```

## `std::bit_cast` vs `reinterpret_cast`

- `std::bit_cast`: Ideal for converting between types with the same binary representation
- `reinterpret_cast`: Commonly used for pointer conversions, such as converting a pointer to an integer type or vice versa

```cpp
#include <bit>
#include <cstring>
#include <iostream>
#include <vector>

struct TickData {
    int id;
    double price;
    float prices[10];
};

int main() {
    auto tick = TickData{100, 1.22, 10, 20, 30};
    std::vector<char> bytes(sizeof(TickData));
    std::memcpy(bytes.data(), &tick, sizeof(TickData));
    {
        // by reinterpret_cast
        auto tick_ptr = reinterpret_cast<TickData*>(bytes.data());
        std::cout << tick_ptr->price << '\n';
    }
    {
        // by std::bit_cast, more safe
        auto tick_ptr = std::bit_cast<TickData*>(bytes.data());
        std::cout << tick_ptr->price << '\n';
    }
}
```