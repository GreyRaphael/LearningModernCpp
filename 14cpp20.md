# C++20 libraries

- [C++20 libraries](#c20-libraries)
  - [`std::ranges`](#stdranges)
    - [projection](#projection)
    - [transform](#transform)
    - [split \& join](#split--join)
  - [`std::span`](#stdspan)
  - [`std:jthread`](#stdjthread)
  - [`auto`](#auto)
    - [unconstrained `auto`](#unconstrained-auto)
    - [constrained `auto` of `concept`](#constrained-auto-of-concept)
  - [`std::erase`](#stderase)
  - [`concepts`](#concepts)
    - [comparing numbers](#comparing-numbers)
    - [computing the average](#computing-the-average)
    - [factory with variable arguments](#factory-with-variable-arguments)
  - [structured bindings](#structured-bindings)
  - [c++20 ezlog](#c20-ezlog)

## `std::ranges`

C++17 use [ranges](https://github.com/ericniebler/range-v3)
> `vcpkg install range-v3`

```cmake
find_package(range-v3 CONFIG REQUIRED)
target_link_libraries(my_project PRIVATE range-v3::meta range-v3::concepts range-v3::range-v3)
```

simple usage of `ranges`

```cpp
#include <iostream>
#include <ranges>

int main() {
    // [1, 10), std::views in <ranges>
    for (auto i : std::views::iota(1, 10)) {
        std::cout << i << ' ';
    }
}
```

ranges with pipeline `|`

```cpp
#include <cmath>
#include <iostream>
#include <ranges>

bool is_prime(int const n) {
    if (n != 2) {
        if (n < 2 || n % 2 == 0) return false;
        auto root = std::sqrt(n);
        for (int i = 3; i <= root; i += 2) {
            if (n % i == 0) return false;
        }
    }
    return true;
}

int main() {
    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    auto v = {1, 2, 3, 4, 5, 6, 7, 8, 9};  // initializer_list
    for (auto i : v | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime) | std::views::transform([](int const n) { return n + 1; })) {
        std::cout << i << ' ';
    }  // 3 4 6 8
    std::cout << '\n';

    // take(): take the first-N elements
    // drop(): drop the first-N elements
    for (auto i : std::views::iota(1, 10) | std::views::reverse | std::views::filter(is_prime) | std::views::take(3) | std::views::reverse | std::views::drop(1)) {
        std::cout << i << ' ';
    }  // 5 7
    std::cout << '\n';
}
```

ranges with algorithms

```cpp
#include <algorithm>  // max,sort,reverse,copy, count_if...in-place
#include <iostream>
#include <iterator>  // std::ostream_iterator
#include <ranges>
#include <vector>

int main() {
    // algorithms
    std::vector v{5, 2, 7, 1, 4, 2, 9, 5};
    std::cout << std::ranges::max(v) << '\n';           // 9
    std::cout << *std::ranges::max_element(v) << '\n';  // 9

    std::ranges::sort(v);
    for (auto& e : v) std::cout << e << ' ';  // 1 2 2 4 5 5 7 9
    std::cout << '\n';

    std::ranges::reverse(v);
    std::ranges::copy(v, std::ostream_iterator<int>(std::cout, ","));  // 9,7,5,5,4,2,2,1,
    std::cout << '\n';

    auto n = std::ranges::count_if(v, [](int const n) { return n % 2 == 0; });
    std::cout << n << '\n';  // 3
}
```

### projection

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <string>
#include <utility>

void printIterable(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << e << ' ';
    }
    std::cout << '\n';
}

void printPairs(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << std::format("({}, {}) ", e.first, e.second);
    }
    std::cout << '\n';
}

int main() {
    {
        int arr[] = {7, 2, 3, 5};
        // sort ascending
        std::ranges::sort(arr);  // std::ranges::less{}
        printIterable(arr);      // 2 3 5 7
    }
    {
        int arr[] = {7, 2, 3, 5};
        // sort descending
        std::ranges::sort(arr, std::ranges::greater{});
        printIterable(arr);  // 7 5 3 2
    }
    {
        std::pair<int, std::string> arr[] = {
            {7, "seven"},
            {2, "two"},
            {3, "three"},
            {5, "five"},
        };
        // sort descending by first element as projection
        std::ranges::sort(arr, std::ranges::greater{}, [](auto const& p) { return p.first; });
        printPairs(arr);  // (7, seven) (5, five) (3, three) (2, two)
    }
}
```

projection with struct

```cpp
#include <algorithm>
#include <format>
#include <iostream>
#include <ranges>
#include <vector>

struct Box {
    std::string name;
    double w = 0.0;
    double h = 0.0;
    double d = 0.0;

    constexpr double volume() const { return w * h * d; }
};

void print(std::string_view intro, const std::vector<Box>& container) {
    std::cout << intro << '\n';
    for (const auto& elem : container)
        std::cout << std::format("{}, volume {}\n", elem.name, elem.volume());
}

int main() {
    std::vector<Box> container{
        {"large cubic", 10, 10, 10},
        {"small cubic", 3, 3, 3},
        {"large long", 10, 2, 2},
        {"small", 3, 2, 2},
    };

    std::ranges::sort(container, {}, &Box::name);  // project by field
    print("===>after sorting by name", container);
    std::ranges::sort(container, {}, &Box::volume);  // projection by method
    print("===>after sorting by volume", container);
}
```

sort by secondary key

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <ranges>
#include <tuple>
#include <vector>

template <typename Proj = std::identity>
void PrintEx(const std::ranges::range auto& container, Proj proj = {}) {
    for (size_t i = 0; auto&& elem : container)
        std::cout << std::invoke(proj, elem) << (++i == container.size() ? "\n" : ", ");
};

struct Score {
    int math;
    int physics;
    std::string name;
};

int main() {
    std::vector<Score> scores = {
        {5, 6, "moris"},
        {2, 4, "tom"},
        {1, 1, "jerry"},
        {1, 0, "bob"},
        {8, 10, "grey"},
    };
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (5,6,moris), (2,4,tom), (1,1,jerry), (1,0,bob), (8,10,grey)

    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return x.math < y.math; }); // sort by single field
    std::ranges::sort(scores, {}, &Score::math);
    // (1,1,jerry), (1,0,bob), (2,4,tom), (5,6,moris), (8,10,grey)

    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // use std::make_tuple
    // math in desc order, name[0] in asc order
    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return std::make_tuple(-x.math, x.name[0]) < std::make_tuple(-y.math, y.name[0]); }); // method1
    std::ranges::sort(scores, {}, [](auto const& x) { return std::make_tuple(-x.math, x.name[0]); });  // method2
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (8,10,grey), (5,6,moris), (2,4,tom), (1,0,bob), (1,1,jerry)
};
```

### transform

```cpp
#include <algorithm>
#include <iostream>
#include <ranges>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    std::vector<Product> prods{7, {"Box ", 1.0}};

    // standard version:
    std::transform(prods.begin(), prods.end(), prods.begin(), [v = 0](const Product &p) mutable {
        return Product{p.name_ + std::to_string(v++), 1.0};
    });
    for (auto &p : prods) std::cout << p.name_ << ", ";
    std::cout << '\n';

    // ranges version:
    std::ranges::transform(prods, prods.begin(), [v = 0](const std::string &n) mutable { return Product{n + std::to_string(v++), 1.0}; }, &Product::name_);
    for (auto &p : prods) std::cout << p.name_ << ", ";
}
```


```cpp
#include <algorithm>
#include <iostream>
#include <map>
#include <ranges>

template <typename T>
size_t MaxKeyLength(const std::map<std::string, T>& m) {
    if (m.empty())
        return 0;
    auto res = std::ranges::max_element(std::views::keys(m),
                                        std::less{}, &std::string::length  // <<
    );
    return (*res).length();
}

int main() {
    const std::map<std::string, std::array<double, 5>> productToOrders{
        {"apples", {100, 200, 50.5, 30, 10}},
        {"bananas", {80, 10, 100, 120, 70}},
        {"carrots", {130, 75, 25, 64.5, 128}},
        {"tomatoes", {70, 100, 170, 80, 90}}};
    auto maxKeyLength = MaxKeyLength(productToOrders);
    std::cout << maxKeyLength << '\n';  // 8
}
```

transform with two ranges

```cpp
#include <algorithm>
#include <format>
#include <iostream>
#include <ranges>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    std::vector<Product> prods{7, {"Box", 1.0}};
    auto nums = std::views::iota(1, 3);
    // combine two ranges
    std::ranges::transform(prods, nums, prods.begin(), [](auto &p, auto n) {
        return Product{std::format("{}-{}", p.name_, n), p.value_};
    });
    for (auto &p : prods) std::cout << p.name_ << ','; // Box-1,Box-2,Box,Box,Box,Box,Box,
}
```

### split & join

split string

```cpp
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>

auto split(std::string_view s, std::string_view delim) {
    std::vector<std::string_view> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::string source{"Hello^_^C++^_^20^_^!"};
    std::string delims = "^_^";
    auto result = split(source, delims);
    for (auto &&e : result) {
        std::cout << e << std::endl;
    }
}
```

split vector of int

```cpp
#include <iostream>
#include <ranges>
#include <vector>

auto split(std::span<int> s, std::span<int> delim) {
    std::vector<std::span<int>> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::vector source = {1, 2, 3, 6, 6, 2, 3, 4, 6, 6, 8};
    std::vector delims = {6, 6};
    auto result = split(source, delims);
    for (auto &&v : result) {
        for (auto &&e : v) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
}
// 1 2 3 
// 2 3 4 
// 8 
```

join strings and vectors

```cpp
#include <ranges>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto result = v | std::views::join;
        std::string output{result.begin(), result.end()};  // helloworldgrey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        auto result = v | std::views::join;
        std::vector<int> output{};
        output.insert(output.begin(), result.begin(), result.end());  // 1 1 2 2 3 3
    }
}
```

`join` by range-v3, recommended
> but `split` by range-v3 is not recommended

```cpp
#include <range/v3/all.hpp>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto output = v | ranges::views::join("||") | ranges::to<std::string>();  // hello||world||grey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        std::vector delims{6, 6};
        auto output = v | ranges::views::join(delims) | ranges::to<std::vector>();  // 1 1 6 6 2 2 6 6 3 3
    }
}
```

## `std::span`

`std::span` is a lightweight, non-owning **view** over a **contiguous sequence** of objects, which can be used with **C-style arrays**, `std::array`, `std::vector`, and similar container types.
> `std::span` in [details](https://www.cppstories.com/2023/span-cpp20/)

```cpp
#include <iostream>
#include <span>
#include <vector>

void printSpan(std::span<const int> s) {
    for (auto elem : s) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}

int main() {
    // Creating a span from a std::vector
    std::vector<int> vec = {1, 2, 3, 4};
    std::span<int> spanVec(vec);
    printSpan(spanVec);  // 1 2 3 4

    // Creating a span from a C-style array
    int arr[] = {5, 6, 7, 8};
    std::span<int> spanArr(arr);
    printSpan(spanArr);  // 5 6 7 8

    // Creating a span from a std::array
    std::array<int, 5> arr2 = {11, 22, 33, 44, 55};
    std::span<int> spanArr2(arr2);
    printSpan(spanArr2);  // 11 22 33 44 55

    // subspan
    auto first3sp = spanArr2.first(3);
    printSpan(first3sp);  // 11 22 33

    auto last3sp = spanArr2.last(3);
    printSpan(last3sp);  // 33 44 55

    auto middle3sp = spanArr2.subspan(1, 3);
    printSpan(middle3sp);  // 22 33 44
}
```

`std::span<T>` & `std::span<const T>`

```cpp
#include <iostream>
#include <span>
#include <string>

void transform(std::span<char> outbuf) {
    for (auto& elem : outbuf) {
        elem += 1;
    }
}

void output(std::span<const char> outbuf) {
    std::cout << "contents: ";
    for (auto& elem : outbuf) {
        std::cout << elem << ", ";
        // elem = 0;  // error!
    }
    std::cout << '\n';
}

int main() {
    std::string str = "Hello World";
    std::span<char> buf_span(str);

    output(str);

    transform(buf_span);

    output(buf_span);  // contents: I, f, m, m, p, !, X, p, s, m, e,
    output(str);       // contents: I, f, m, m, p, !, X, p, s, m, e,
}
```

## `std:jthread`

jthread with bracket

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// ====================
// worker-2 start
// worker-3 start
// worker-4 start
// worker-1 start
// worker-1 finish
// worker-4 finish
// worker-3 finish
// worker-2 finish
```

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
    }
    // wait t1, t2 finished
    {
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// worker-1 start
// worker-2 start
// worker-2 finish
// worker-1 finish
// ====================
// worker-3 start
// worker-4 start
// worker-4 finish
// worker-3 finish
```

## `auto`

### unconstrained `auto`

```cpp
// before C++20
template <typename T>
void myTemplateFunc(T param) {}

// equivalent, since C++20
void myTemplateFunc(auto param) {}
```

```cpp
#include <iostream>

// before C++20
template <typename T>
void printValOld(T v) {
    std::cout << v << '\n';
}

// since C++20
void printValNew(auto v) {
    std::cout << v << '\n';
}

int main() {
    // before
    printValOld(10);
    printValOld(1.2);
    printValOld<long>(100);

    // since C++20
    printValNew(20);
    printValNew(2.3);
    printValNew<long>(200);
}
```

### constrained `auto` of `concept`

```cpp
#include <concepts>

class A {};

class B : public A {};

class C {};

// custom concept
template <class T>
concept SignedIntegral = std::is_signed_v<T> && std::is_integral_v<T>;

void myfunc1(SignedIntegral auto val) {}

// standard concepts
void myfunc2(std::floating_point auto fp) {}
void myfunc3(std::signed_integral auto param) {}
void myfunc4(std::unsigned_integral auto param) {}
void myfunc5(std::derived_from<A> auto param) {}

int main() {
    A a{};
    B b{};
    C c{};
    myfunc5(a);  // ok
    myfunc5(b);  // ok
    // myfunc5(c);  // error
}
```

## `std::erase`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector vec{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    // erase a single value
    std::erase(vec, 5);
    // erase by predicate
    std::erase_if(vec, [](auto& v) { return v % 2 == 0; });
    for (int i = 0; auto& v : vec)
        std::cout << i++ << ": " << v << '\n';  // 1 3 7 9
}
```

```cpp
#include <iostream>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    const std::vector<Product> prods{
        {"box", 10.0},
        {"tv", 100.0},
        {"rocket", 10000.0},
        {"no prod", 0.0},
        {"car", 1000.0},
        {"toy", 40.0},
        {"none", 0.0}};

    auto printCont = [](const std::vector<Product>& cont) {
        for (auto& p : cont) std::cout << p.name_ << ", ";
        std::cout << '\n';
    };
    printCont(prods);

    auto checkNoPrefix = [&](const Product& p) { return p.name_.starts_with("no"); };

    auto tempProds = prods; // const to mutable
    // C++20 version:
    std::erase_if(tempProds, checkNoPrefix);
    printCont(tempProds);
}
```

## `concepts`

### comparing numbers

```cpp
#include <concepts>
#include <cstdlib>
#include <type_traits>

template <typename T>
constexpr auto precision_threshold = T(1e-6);

// in c++17, if constexpr
template <typename T>
constexpr bool close_enough(T a, T b) {
    if constexpr (std::is_floating_point_v<T>)
        return std::abs(a - b) < precision_threshold<T>;
    else
        return a == b;
}

// in c++20, by concepts
template <typename T>
    requires std::is_floating_point_v<T>
constexpr bool close_enough20(T a, T b) {
    return std::abs(a - b) < precision_threshold<T>;
}
constexpr bool close_enough20(auto a, auto b) {
    return a == b;
}

// c++20, simplified 01, recommended
constexpr bool close_enough201(std::floating_point auto a, std::floating_point auto b) {
    return std::abs(a - b) < precision_threshold<std::common_type_t<decltype(a), decltype(b)>>;
}
constexpr bool close_enough201(std::integral auto a, std::integral auto b) {
    return a == b;
}

// c++20, simplified 02
template <std::floating_point T>
constexpr bool close_enough202(T a, T b) {
    return absolute(a - b) < precision_threshold<T>;
}

constexpr bool close_enough202(std::integral auto a, std::integral auto b) {
    return a == b;
}

int main() {
    // c++17
    static_assert(close_enough(10, 20) == false);
    static_assert(close_enough(10, 10) == true);
    static_assert(close_enough(10.1, 10.1) == true);
    static_assert(close_enough(10.0000001, 10.0000005) == true);
    // c++20
    static_assert(close_enough20(10, 20) == false);
    static_assert(close_enough20(10, 10) == true);
    static_assert(close_enough20(10.1, 10.1) == true);
    static_assert(close_enough20(10.0000001, 10.0000005) == true);
}
```

### computing the average

```cpp
#include <iostream>
#include <numeric>
#include <type_traits>
#include <vector>

template <typename T>
    requires std::is_integral_v<T> || std::is_floating_point_v<T>
constexpr double Average(std::vector<T> const &vec) {
    const double sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / static_cast<double>(vec.size());
}

template <typename T>
concept numeric = std::is_integral_v<T> || std::is_floating_point_v<T>;

template <typename T>
    requires numeric<T>
constexpr double Average2(std::vector<T> const &vec) {
    const double sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / static_cast<double>(vec.size());
}

// simplest, <numeric auto> not support in clang18
constexpr auto Average3(std::vector<numeric auto> const &vec) {
    const auto sum = std::accumulate(vec.begin(), vec.end(), 0.0);
    return sum / vec.size();
}

int main() {
    std::vector ints{1, 2, 3, 4, 5};
    std::cout << Average3(ints) << '\n';

    std::vector floats{1.1f, 2.2f, 3.3f, 4.4f, 5.5f};
    std::cout << Average3(floats) << '\n';
}
```

### factory with variable arguments

```cpp
#include <iostream>
#include <memory>

class Investment {
   public:
    virtual ~Investment() {}

    virtual void calcRisk() = 0;
};

class Stock : public Investment {
   public:
    explicit Stock(const std::string &) {}

    void calcRisk() override {
        std::cout << "===>stock risk" << '\n';
    }
};

class Bond : public Investment {
   public:
    explicit Bond(const std::string &, const std::string &, int) {}

    void calcRisk() override {
        std::cout << "===>bond risk" << '\n';
    }
};

class RealEstate : public Investment {
   public:
    explicit RealEstate(const std::string &, double, int) {}

    void calcRisk() override {
        std::cout << "===>realestate risk" << '\n';
    }
};

// C++17
template <typename Concrete, typename... Ts>
std::unique_ptr<Concrete> constructArgs17(Ts &&...params) {
    if constexpr (std::is_constructible_v<Concrete, Ts...>)
        return std::make_unique<Concrete>(std::forward<Ts>(params)...);
    else
        return nullptr;
}

// C++17
template <typename... Ts>
std::unique_ptr<Investment> makeInvestment17(const std::string &name, Ts &&...params) {
    std::cout << __func__ << ", " << name << std::endl;

    std::unique_ptr<Investment> pInv;

    if (name == "Stock")
        pInv = constructArgs17<Stock, Ts...>(std::forward<Ts>(params)...);
    else if (name == "Bond")
        pInv = constructArgs17<Bond, Ts...>(std::forward<Ts>(params)...);
    else if (name == "RealEstate")
        pInv = constructArgs17<RealEstate, Ts...>(std::forward<Ts>(params)...);

    if (pInv) {
        pInv->calcRisk();  // calc initial risk and cache result...
    } else
        std::cout << "nullptr from \'makeInvestment17\'" << std::endl;

    return pInv;
}

// C++20:
template <typename Concrete, typename... Ts>
    requires std::is_constructible_v<Concrete, Ts...>
std::unique_ptr<Concrete> constructArgs20(Ts &&...params) {
    return std::make_unique<Concrete>(std::forward<Ts>(params)...);
}

template <typename Concrete, typename... Ts>
std::unique_ptr<Concrete> constructArgs20(...) {
    return nullptr;
}

// C++20
template <typename... Ts>
std::unique_ptr<Investment> makeInvestment20(const std::string &name, Ts &&...params) {
    std::cout << __func__ << ", " << name << std::endl;

    std::unique_ptr<Investment> pInv;

    if (name == "Stock")
        pInv = constructArgs20<Stock, Ts...>(std::forward<Ts>(params)...);
    else if (name == "Bond")
        pInv = constructArgs20<Bond, Ts...>(std::forward<Ts>(params)...);
    else if (name == "RealEstate")
        pInv = constructArgs20<RealEstate, Ts...>(std::forward<Ts>(params)...);

    if (pInv) {
        pInv->calcRisk();  // calc initial risk and cache result...
    } else
        std::cout << "nullptr from \'makeInvestment20\'" << std::endl;

    return pInv;
}

int main() {
    // C++17
    {
        auto noArgs = makeInvestment17("Stock");
        auto pStock = makeInvestment17("Stock", "abc");
        auto pBond = makeInvestment17("Bond", "xyz", "2210", 5);
        auto pRealEstate = makeInvestment17("RealEstate", "CA", 0.75, 10);
        auto nothing = makeInvestment17("SomethingElse", '?');
    }
    // C++20
    {
        auto noArgs = makeInvestment20("Stock");
        auto pStock = makeInvestment20("Stock", "abc");
        auto pBond = makeInvestment20("Bond", "xyz", "2210", 5);
        auto pRealEstate = makeInvestment20("RealEstate", "CA", 0.75, 10);
        auto nothing = makeInvestment20("SomethingElse", '?');
    }
}
```

## structured bindings

since c++17

```cpp
#include <array>
#include <iostream>
#include <map>
#include <string>
#include <tuple>
#include <utility>

struct Student {
    int id;
    std::string name;
    double gpa;
};

int main(int argc, char const* argv[]) {
    {
        // pair, 2 elements
        auto p = std::make_pair(10, 1.2);
        auto [first, second] = p;
        auto const& [first2, second2] = p;
    }
    {
        // tuple
        auto t = std::make_tuple(1, 2.2, 'c', "string");
        auto [a, b, c, d] = t;
        std::cout << d << '\n';
    }
    {
        // c-array
        double arr1[3] = {1.1, 2.2, 3.3};
        auto [a, b, c] = arr1;
        // std::array
        std::array arr2 = {1, 2, 3};
        auto [x, y, z] = arr2;
    }
    {
        // struct with non-static data members
        Student s = {1, "name", 3.3};
        auto [id, name, gpa] = s;
    }
    {
        // map
        std::map<std::string, int> m = {{"one", 1111}, {"two", 2222}, {"three", 3333}};
        for (auto const& [k, v] : m) {
            std::cout << k << ": " << v << '\n';
        }
        // iter with counter
        for (auto i = 1; auto const& [k, v] : m) {
            std::cout << i++ << ':' << k << ": " << v << '\n';
        }
    }
}
```

## c++20 ezlog

> by `std::source_location`

```cpp
// ezlog.hpp
#pragma once

#include <chrono>
#include <filesystem>
#include <format>
#include <iostream>
#include <source_location>
#include <string_view>

namespace ezlog {

enum class log_level : unsigned char {
    Debug = 34,    // BLUE
    Info = 32,     // GREEN
    Warning = 33,  // YELLOW
    Error = 31,    // RED
};

constexpr std::string_view level2txt(log_level const level) {
    switch (level) {
        case log_level::Debug:
            return "debug";
        case log_level::Info:
            return "info";
        case log_level::Warning:
            return "warn";
        case log_level::Error:
            return "error";
        default:
            return "unknown";
    }
}

inline void log(log_level const level, std::string_view message, std::source_location const source = std::source_location::current()) {
    auto now = std::chrono::floor<std::chrono::milliseconds>(std::chrono::system_clock::now());
    auto zoned_time_str = std::format("{:%F %H:%M:%S}", std::chrono::zoned_time{std::chrono::current_zone(), now});
    auto loc_str = std::format("{}:{}", std::filesystem::path(source.file_name()).filename().string(), source.line());
    auto color_flag = std::format("\033[{}m{}\033[0m", static_cast<unsigned char>(level), level2txt(level));
    std::cout << std::format("[{}] [{}] [{}] {}\n", color_flag, zoned_time_str, loc_str, message);
}

inline void debug(std::string_view message, std::source_location const source = std::source_location::current()) {
    log(log_level::Debug, message, source);
}

inline void info(std::string_view message, std::source_location const source = std::source_location::current()) {
    log(log_level::Info, message, source);
}

inline void warn(std::string_view message, std::source_location const source = std::source_location::current()) {
    log(log_level::Warning, message, source);
}

inline void error(std::string_view message, std::source_location const source = std::source_location::current()) {
    log(log_level::Error, message, source);
}
}  // namespace ezlog
```