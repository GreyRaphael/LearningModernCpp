# C++20 libraries

- [C++20 libraries](#c20-libraries)
  - [`std::ranges`](#stdranges)
    - [projection](#projection)
    - [transform](#transform)
    - [split \& join](#split--join)
  - [`std::span`](#stdspan)
  - [`std:jthread`](#stdjthread)
  - [`auto`](#auto)
    - [unconstrained `auto`](#unconstrained-auto)
    - [constrained `auto` of `concept`](#constrained-auto-of-concept)

## `std::ranges`

C++17 use [ranges](https://github.com/ericniebler/range-v3)
> `vcpkg install range-v3`

```cmake
find_package(range-v3 CONFIG REQUIRED)
target_link_libraries(my_project PRIVATE range-v3::meta range-v3::concepts range-v3::range-v3)
```

simple usage of `ranges`

```cpp
#include <iostream>
#include <ranges>

int main() {
    // [1, 10), std::views in <ranges>
    for (auto i : std::views::iota(1, 10)) {
        std::cout << i << ' ';
    }
}
```

ranges with pipeline `|`

```cpp
#include <cmath>
#include <iostream>
#include <ranges>

bool is_prime(int const n) {
    if (n != 2) {
        if (n < 2 || n % 2 == 0) return false;
        auto root = std::sqrt(n);
        for (int i = 3; i <= root; i += 2) {
            if (n % i == 0) return false;
        }
    }
    return true;
}

int main() {
    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    auto v = {1, 2, 3, 4, 5, 6, 7, 8, 9};  // initializer_list
    for (auto i : v | std::views::filter(is_prime)) {
        std::cout << i << ' ';
    }  // 2 3 5 7
    std::cout << '\n';

    for (auto i : std::views::iota(1, 10) | std::views::filter(is_prime) | std::views::transform([](int const n) { return n + 1; })) {
        std::cout << i << ' ';
    }  // 3 4 6 8
    std::cout << '\n';

    // take(): take the first-N elements
    // drop(): drop the first-N elements
    for (auto i : std::views::iota(1, 10) | std::views::reverse | std::views::filter(is_prime) | std::views::take(3) | std::views::reverse | std::views::drop(1)) {
        std::cout << i << ' ';
    }  // 5 7
    std::cout << '\n';
}
```

ranges with algorithms

```cpp
#include <algorithm>  // max,sort,reverse,copy, count_if...in-place
#include <iostream>
#include <iterator>  // std::ostream_iterator
#include <ranges>
#include <vector>

int main() {
    // algorithms
    std::vector v{5, 2, 7, 1, 4, 2, 9, 5};
    std::cout << std::ranges::max(v) << '\n';           // 9
    std::cout << *std::ranges::max_element(v) << '\n';  // 9

    std::ranges::sort(v);
    for (auto& e : v) std::cout << e << ' ';  // 1 2 2 4 5 5 7 9
    std::cout << '\n';

    std::ranges::reverse(v);
    std::ranges::copy(v, std::ostream_iterator<int>(std::cout, ","));  // 9,7,5,5,4,2,2,1,
    std::cout << '\n';

    auto n = std::ranges::count_if(v, [](int const n) { return n % 2 == 0; });
    std::cout << n << '\n';  // 3
}
```

### projection

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <string>
#include <utility>

void printIterable(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << e << ' ';
    }
    std::cout << '\n';
}

void printPairs(const auto& iterable) {
    std::cout << std::string(20, '-') << std::endl;
    for (auto&& e : iterable) {
        std::cout << std::format("({}, {}) ", e.first, e.second);
    }
    std::cout << '\n';
}

int main() {
    {
        int arr[] = {7, 2, 3, 5};
        // sort ascending
        std::ranges::sort(arr);  // std::ranges::less{}
        printIterable(arr);      // 2 3 5 7
    }
    {
        int arr[] = {7, 2, 3, 5};
        // sort descending
        std::ranges::sort(arr, std::ranges::greater{});
        printIterable(arr);  // 7 5 3 2
    }
    {
        std::pair<int, std::string> arr[] = {
            {7, "seven"},
            {2, "two"},
            {3, "three"},
            {5, "five"},
        };
        // sort descending by first element as projection
        std::ranges::sort(arr, std::ranges::greater{}, [](auto const& p) { return p.first; });
        printPairs(arr);  // (7, seven) (5, five) (3, three) (2, two)
    }
}
```

projection with struct

```cpp
#include <algorithm>
#include <format>
#include <iostream>
#include <ranges>
#include <vector>

struct Box {
    std::string name;
    double w = 0.0;
    double h = 0.0;
    double d = 0.0;

    constexpr double volume() const { return w * h * d; }
};

void print(std::string_view intro, const std::vector<Box>& container) {
    std::cout << intro << '\n';
    for (const auto& elem : container)
        std::cout << std::format("{}, volume {}\n", elem.name, elem.volume());
}

int main() {
    std::vector<Box> container{
        {"large cubic", 10, 10, 10},
        {"small cubic", 3, 3, 3},
        {"large long", 10, 2, 2},
        {"small", 3, 2, 2},
    };

    std::ranges::sort(container, {}, &Box::name);  // project by field
    print("===>after sorting by name", container);
    std::ranges::sort(container, {}, &Box::volume);  // projection by method
    print("===>after sorting by volume", container);
}
```

sort by secondary key

```cpp
#include <algorithm>
#include <format>
#include <functional>
#include <iostream>
#include <ranges>
#include <tuple>
#include <vector>

template <typename Proj = std::identity>
void PrintEx(const std::ranges::range auto& container, Proj proj = {}) {
    for (size_t i = 0; auto&& elem : container)
        std::cout << std::invoke(proj, elem) << (++i == container.size() ? "\n" : ", ");
};

struct Score {
    int math;
    int physics;
    std::string name;
};

int main() {
    std::vector<Score> scores = {
        {5, 6, "moris"},
        {2, 4, "tom"},
        {1, 1, "jerry"},
        {1, 0, "bob"},
        {8, 10, "grey"},
    };
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (5,6,moris), (2,4,tom), (1,1,jerry), (1,0,bob), (8,10,grey)

    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return x.math < y.math; }); // sort by single field
    std::ranges::sort(scores, {}, &Score::math);
    // (1,1,jerry), (1,0,bob), (2,4,tom), (5,6,moris), (8,10,grey)

    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // use std::make_tuple
    // math in desc order, name[0] in asc order
    // std::ranges::sort(scores, [](auto const& x, auto const& y) { return std::make_tuple(-x.math, x.name[0]) < std::make_tuple(-y.math, y.name[0]); }); // method1
    std::ranges::sort(scores, {}, [](auto const& x) { return std::make_tuple(-x.math, x.name[0]); });  // method2
    PrintEx(scores, [](auto const& x) { return std::format("({},{},{})", x.math, x.physics, x.name); });
    // (8,10,grey), (5,6,moris), (2,4,tom), (1,0,bob), (1,1,jerry)
};
```

### transform

```cpp
#include <algorithm>
#include <iostream>
#include <ranges>
#include <vector>

struct Product {
    std::string name_;
    double value_{0.0};
};

int main() {
    std::vector<Product> prods{7, {"Box ", 1.0}};

    // standard version:
    std::transform(prods.begin(), prods.end(), prods.begin(), [v = 0](const Product &p) mutable {
        return Product{p.name_ + std::to_string(v++), 1.0};
    });
    for (auto &p : prods) std::cout << p.name_ << ", ";
    std::cout << '\n';

    // ranges version:
    std::ranges::transform(prods, prods.begin(), [v = 0](const std::string &n) mutable { return Product{n + std::to_string(v++), 1.0}; }, &Product::name_);
    for (auto &p : prods) std::cout << p.name_ << ", ";
}
```


```cpp
#include <algorithm>
#include <iostream>
#include <map>
#include <ranges>

template <typename T>
size_t MaxKeyLength(const std::map<std::string, T>& m) {
    if (m.empty())
        return 0;
    auto res = std::ranges::max_element(std::views::keys(m),
                                        std::less{}, &std::string::length  // <<
    );
    return (*res).length();
}

int main() {
    const std::map<std::string, std::array<double, 5>> productToOrders{
        {"apples", {100, 200, 50.5, 30, 10}},
        {"bananas", {80, 10, 100, 120, 70}},
        {"carrots", {130, 75, 25, 64.5, 128}},
        {"tomatoes", {70, 100, 170, 80, 90}}};
    auto maxKeyLength = MaxKeyLength(productToOrders);
    std::cout << maxKeyLength << '\n';  // 8
}
```

### split & join

split string

```cpp
#include <iostream>
#include <ranges>
#include <string_view>
#include <vector>

auto split(std::string_view s, std::string_view delim) {
    std::vector<std::string_view> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::string source{"Hello^_^C++^_^20^_^!"};
    std::string delims = "^_^";
    auto result = split(source, delims);
    for (auto &&e : result) {
        std::cout << e << std::endl;
    }
}
```

split vector of int

```cpp
#include <iostream>
#include <ranges>
#include <vector>

auto split(std::span<int> s, std::span<int> delim) {
    std::vector<std::span<int>> output;
    for (auto e : std::views::split(s, delim)) {
        output.emplace_back(e.begin(), e.end());
    }
    return output;
}

int main() {
    std::vector source = {1, 2, 3, 6, 6, 2, 3, 4, 6, 6, 8};
    std::vector delims = {6, 6};
    auto result = split(source, delims);
    for (auto &&v : result) {
        for (auto &&e : v) {
            std::cout << e << ' ';
        }
        std::cout << '\n';
    }
}
// 1 2 3 
// 2 3 4 
// 8 
```

join strings and vectors

```cpp
#include <ranges>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto result = v | std::views::join;
        std::string output{result.begin(), result.end()};  // helloworldgrey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        auto result = v | std::views::join;
        std::vector<int> output{};
        output.insert(output.begin(), result.begin(), result.end());  // 1 1 2 2 3 3
    }
}
```

`join` by range-v3, recommended
> but `split` by range-v3 is not recommended

```cpp
#include <range/v3/all.hpp>
#include <string>
#include <vector>

int main() {
    {
        // join string
        std::vector<std::string> v{"hello", "world", "grey"};
        auto output = v | ranges::views::join("||") | ranges::to<std::string>();  // hello||world||grey
    }
    {
        // join ints
        std::vector<std::vector<int>> v{
            {1, 1},
            {2, 2},
            {3, 3},
        };
        std::vector delims{6, 6};
        auto output = v | ranges::views::join(delims) | ranges::to<std::vector>();  // 1 1 6 6 2 2 6 6 3 3
    }
}
```

## `std::span`

`std::span` is a lightweight, non-owning **view** over a **contiguous sequence** of objects, which can be used with **C-style arrays**, `std::array`, `std::vector`, and similar container types.
> `std::span` in [details](https://www.cppstories.com/2023/span-cpp20/)

```cpp
#include <iostream>
#include <span>
#include <vector>

void printSpan(std::span<const int> s) {
    for (auto elem : s) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}

int main() {
    // Creating a span from a std::vector
    std::vector<int> vec = {1, 2, 3, 4};
    std::span<int> spanVec(vec);
    printSpan(spanVec);  // 1 2 3 4

    // Creating a span from a C-style array
    int arr[] = {5, 6, 7, 8};
    std::span<int> spanArr(arr);
    printSpan(spanArr);  // 5 6 7 8

    // Creating a span from a std::array
    std::array<int, 5> arr2 = {11, 22, 33, 44, 55};
    std::span<int> spanArr2(arr2);
    printSpan(spanArr2);  // 11 22 33 44 55

    // subspan
    auto first3sp = spanArr2.first(3);
    printSpan(first3sp);  // 11 22 33

    auto last3sp = spanArr2.last(3);
    printSpan(last3sp);  // 33 44 55

    auto middle3sp = spanArr2.subspan(1, 3);
    printSpan(middle3sp);  // 22 33 44
}
```

`std::span<T>` & `std::span<const T>`

```cpp
#include <iostream>
#include <span>
#include <string>

void transform(std::span<char> outbuf) {
    for (auto& elem : outbuf) {
        elem += 1;
    }
}

void output(std::span<const char> outbuf) {
    std::cout << "contents: ";
    for (auto& elem : outbuf) {
        std::cout << elem << ", ";
        // elem = 0;  // error!
    }
    std::cout << '\n';
}

int main() {
    std::string str = "Hello World";
    std::span<char> buf_span(str);

    output(str);

    transform(buf_span);

    output(buf_span);  // contents: I, f, m, m, p, !, X, p, s, m, e,
    output(str);       // contents: I, f, m, m, p, !, X, p, s, m, e,
}
```

## `std:jthread`

jthread with bracket

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// ====================
// worker-2 start
// worker-3 start
// worker-4 start
// worker-1 start
// worker-1 finish
// worker-4 finish
// worker-3 finish
// worker-2 finish
```

```cpp
void task(int i) {
    std::cout << std::format("worker-{} start\n", i);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << std::format("worker-{} finish\n", i);
}

int main(int argc, char const *argv[]) {
    {
        std::jthread t1{task, 1};
        std::cout << std::string(20, '-') << std::endl;
        std::jthread t2{task, 2};
    }
    // wait t1, t2 finished
    {
        std::jthread t3{task, 3};
        std::cout << std::string(20, '=') << std::endl;
        std::jthread t4{task, 4};
    }
}
// --------------------
// worker-1 start
// worker-2 start
// worker-2 finish
// worker-1 finish
// ====================
// worker-3 start
// worker-4 start
// worker-4 finish
// worker-3 finish
```

## `auto`

### unconstrained `auto`

```cpp
// before C++20
template <typename T>
void myTemplateFunc(T param) {}

// equivalent, since C++20
void myTemplateFunc(auto param) {}
```

```cpp
#include <iostream>

// before C++20
template <typename T>
void printValOld(T v) {
    std::cout << v << '\n';
}

// since C++20
void printValNew(auto v) {
    std::cout << v << '\n';
}

int main() {
    // before
    printValOld(10);
    printValOld(1.2);
    printValOld<long>(100);

    // since C++20
    printValNew(20);
    printValNew(2.3);
    printValNew<long>(200);
}
```

### constrained `auto` of `concept`

```cpp
#include <concepts>

class A {};

class B : public A {};

class C {};

// custom concept
template <class T>
concept SignedIntegral = std::is_signed_v<T> && std::is_integral_v<T>;

void myfunc1(SignedIntegral auto val) {}

// standard concepts
void myfunc2(std::floating_point auto fp) {}
void myfunc3(std::signed_integral auto param) {}
void myfunc4(std::unsigned_integral auto param) {}
void myfunc5(std::derived_from<A> auto param) {}

int main() {
    A a{};
    B b{};
    C c{};
    myfunc5(a);  // ok
    myfunc5(b);  // ok
    // myfunc5(c);  // error
}
```